# -*- coding: utf-8 -*-
"""Quantum Shell Game.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p3-mc7E9QFVLJkQFYzeAZ8N_qoosE1NR
"""

# Install Qiskit (run once)
!pip install qiskit
!pip install qiskit-aer
!pip install pylatexenc
!pip install pyzx

# Quantum Shell Game Simulation
from qiskit import QuantumCircuit, transpile
from qiskit_aer import Aer
import qiskit.qasm3
from qiskit.visualization import plot_histogram
import matplotlib.pyplot as plt
import numpy as np
import pyzx as zx

# Create a quantum circuit with 4 qubits & 3 classical bits
qc = QuantumCircuit(4, 3)

# Step 1: Superposition on q0 and q1
qc.h(0)
qc.h(1)

# Step 2: Convert |110⟩ → |111⟩ (later corrected to |001⟩)
qc.ccx(0, 1, 2)  # If q0=1 and q1=1, flip q2

# Step 3: Copy q0 to ancilla (q3)
qc.cx(0, 3)  # q3 = q0

# Step 4: If q1 and q3 are |0⟩, flip q0 (original q0 and q1 were |00⟩)
qc.x(1)
qc.x(3)
qc.ccx(1, 3, 0)  # If q1=1 and q3=1 (original q1=0 and q0=0), flip q0
qc.x(1)
qc.x(3)

# Step 5: Reset ancilla (uncompute)
qc.cx(0, 3)  # Bring q3 back to |0⟩

# Step 6: Ensure |111⟩ becomes |001⟩
# qc.x(2)  # Flip q2 to convert |111⟩ → |001⟩

qc.x(0)
qc.x(1)
# qc.x(2)

# Step 4: Fix to allow only one qubit to be |1⟩
qc.measure([0, 1, 2], [0, 1, 2])  # Temporary measure to debug

# Visualize circuit
print(qc.draw(output='text'))

# Simulate
simulator = Aer.get_backend('qasm_simulator')
new_circuit = transpile(qc, simulator)
result = simulator.run(new_circuit, shots=1000).result()
counts = result.get_counts(qc)

# Show results
print("Measurement results:", counts)
plot_histogram(counts)
plt.show()

qc.remove_final_measurements()  # Removes classical measurements
qasm_str = qiskit.qasm3.Exporter().dumps(qc)
print(qasm_str)

zx_circuit = zx.Circuit.from_qasm(qasm_str)
print(zx_circuit)
zx.draw(zx_circuit)

import json

zx_graph = zx_circuit.to_graph()
zx.draw(zx_graph)
graph_data = zx_graph.to_json()
with open("graph_data.pyzx.json", "w") as f:
    json.dump(graph_data, f, indent=4)

zx.simplify.full_reduce(zx_graph, quiet=False) # simplifies the Graph in-place, and show the rewrite steps taken.
zx_graph.normalize() # Makes the graph more suitable for displaying
zx.draw(zx_graph) # Display the resulting diagram